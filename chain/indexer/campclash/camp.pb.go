// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flux/indexer/campclash/camp.proto

package campclash

import (
	cosmossdk_io_math "cosmossdk.io/math"
	encoding_binary "encoding/binary"
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Enum for operations
type Ops int32

const (
	Ops_OpCreateCamp   Ops = 0
	Ops_OpGraduateCamp Ops = 1
)

var Ops_name = map[int32]string{
	0: "OpCreateCamp",
	1: "OpGraduateCamp",
}

var Ops_value = map[string]int32{
	"OpCreateCamp":   0,
	"OpGraduateCamp": 1,
}

func (x Ops) String() string {
	return proto.EnumName(Ops_name, int32(x))
}

func (Ops) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{0}
}

// Event for camp-related operations
type CampEvent struct {
	ContractAddress string   `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"_contract_address,omitempty" bson:"contract_address"`
	Op              Ops      `protobuf:"varint,2,opt,name=op,proto3,enum=flux.indexer.campclash.Ops" json:"op,omitempty" bson:"op"`
	Project         *Project `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty" bson:"project"`
}

func (m *CampEvent) Reset()         { *m = CampEvent{} }
func (m *CampEvent) String() string { return proto.CompactTextString(m) }
func (*CampEvent) ProtoMessage()    {}
func (*CampEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{0}
}
func (m *CampEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CampEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CampEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CampEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CampEvent.Merge(m, src)
}
func (m *CampEvent) XXX_Size() int {
	return m.Size()
}
func (m *CampEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_CampEvent.DiscardUnknown(m)
}

var xxx_messageInfo_CampEvent proto.InternalMessageInfo

func (m *CampEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *CampEvent) GetOp() Ops {
	if m != nil {
		return m.Op
	}
	return Ops_OpCreateCamp
}

func (m *CampEvent) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

// Event for swap operations
type SwapEvent struct {
	ContractAddress  string                `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"_contract_address,omitempty" bson:"contract_address"`
	CampDenom        string                `protobuf:"bytes,2,opt,name=camp_denom,json=campDenom,proto3" json:"camp_denom,omitempty" bson:"camp_denom"`
	Action           string                `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty" bson:"action"`
	InputCoin        *types.Coin           `protobuf:"bytes,4,opt,name=input_coin,json=inputCoin,proto3" json:"input_coin,omitempty" bson:"input_coin"`
	OutputCoin       *types.Coin           `protobuf:"bytes,5,opt,name=output_coin,json=outputCoin,proto3" json:"output_coin,omitempty" bson:"output_coin"`
	Price            cosmossdk_io_math.Int `protobuf:"bytes,6,opt,name=price,proto3,customtype=cosmossdk.io/math.Int" json:"price" bson:"price"`
	CurveQuoteAmount cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=curve_quote_amount,json=curveQuoteAmount,proto3,customtype=cosmossdk.io/math.Int" json:"curve_quote_amount" bson:"curve_quote_amount"`
	CurveCampAmount  cosmossdk_io_math.Int `protobuf:"bytes,8,opt,name=curve_camp_amount,json=curveCampAmount,proto3,customtype=cosmossdk.io/math.Int" json:"curve_camp_amount" bson:"curve_camp_amount"`
	Trader           string                `protobuf:"bytes,9,opt,name=trader,proto3" json:"trader,omitempty" bson:"trader"`
}

func (m *SwapEvent) Reset()         { *m = SwapEvent{} }
func (m *SwapEvent) String() string { return proto.CompactTextString(m) }
func (*SwapEvent) ProtoMessage()    {}
func (*SwapEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{1}
}
func (m *SwapEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapEvent.Merge(m, src)
}
func (m *SwapEvent) XXX_Size() int {
	return m.Size()
}
func (m *SwapEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SwapEvent proto.InternalMessageInfo

func (m *SwapEvent) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *SwapEvent) GetCampDenom() string {
	if m != nil {
		return m.CampDenom
	}
	return ""
}

func (m *SwapEvent) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *SwapEvent) GetInputCoin() *types.Coin {
	if m != nil {
		return m.InputCoin
	}
	return nil
}

func (m *SwapEvent) GetOutputCoin() *types.Coin {
	if m != nil {
		return m.OutputCoin
	}
	return nil
}

func (m *SwapEvent) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

// Camp structure
type Project struct {
	ContractAddress     string                `protobuf:"bytes,1,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty" bson:"contract_address"`
	CampDenom           string                `protobuf:"bytes,2,opt,name=camp_denom,json=campDenom,proto3" json:"camp_denom,omitempty" bson:"camp_denom"`
	Name                string                `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" bson:"name"`
	Symbol              string                `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty" bson:"symbol"`
	Logo                string                `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty" bson:"logo"`
	Creator             string                `protobuf:"bytes,6,opt,name=creator,proto3" json:"creator,omitempty" bson:"creator"`
	GraduationThreshold cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=graduation_threshold,json=graduationThreshold,proto3,customtype=cosmossdk.io/math.Int" json:"graduation_threshold" bson:"graduation_threshold"`
	GraduationDex       string                `protobuf:"bytes,8,opt,name=graduation_dex,json=graduationDex,proto3" json:"graduation_dex,omitempty" bson:"graduation_dex"`
	Graduated           bool                  `protobuf:"varint,9,opt,name=graduated,proto3" json:"graduated,omitempty" bson:"graduated"`
	PoolSeeded          bool                  `protobuf:"varint,10,opt,name=pool_seeded,json=poolSeeded,proto3" json:"pool_seeded,omitempty" bson:"pool_seeded"`
	PoolAddress         string                `protobuf:"bytes,11,opt,name=pool_address,json=poolAddress,proto3" json:"pool_address,omitempty" bson:"pool_address"`
	GraduateProgress    float64               `protobuf:"fixed64,12,opt,name=graduate_progress,json=graduateProgress,proto3" json:"graduate_progress,omitempty" bson:"graduate_progress"`
	CampAmount          cosmossdk_io_math.Int `protobuf:"bytes,13,opt,name=camp_amount,json=campAmount,proto3,customtype=cosmossdk.io/math.Int" json:"camp_amount" bson:"camp_amount"`
	QuoteDenom          string                `protobuf:"bytes,14,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty" bson:"quote_denom"`
	QuoteAmount         cosmossdk_io_math.Int `protobuf:"bytes,15,opt,name=quote_amount,json=quoteAmount,proto3,customtype=cosmossdk.io/math.Int" json:"quote_amount" bson:"quote_amount"`
	MarketCap           cosmossdk_io_math.Int `protobuf:"bytes,16,opt,name=market_cap,json=marketCap,proto3,customtype=cosmossdk.io/math.Int" json:"market_cap" bson:"market_cap"`
	UpdatedHeight       uint64                `protobuf:"varint,17,opt,name=updated_height,json=updatedHeight,proto3" json:"updated_height,omitempty" bson:"updated_height"`
	Metadata            string                `protobuf:"bytes,18,opt,name=metadata,proto3" json:"metadata,omitempty" bson:"metadata"`
	Metrics             *Metrics              `protobuf:"bytes,19,opt,name=metrics,proto3" json:"metrics,omitempty" bson:"metrics"`
}

func (m *Project) Reset()         { *m = Project{} }
func (m *Project) String() string { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()    {}
func (*Project) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{2}
}
func (m *Project) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Project) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Project.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Project) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Project.Merge(m, src)
}
func (m *Project) XXX_Size() int {
	return m.Size()
}
func (m *Project) XXX_DiscardUnknown() {
	xxx_messageInfo_Project.DiscardUnknown(m)
}

var xxx_messageInfo_Project proto.InternalMessageInfo

func (m *Project) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *Project) GetCampDenom() string {
	if m != nil {
		return m.CampDenom
	}
	return ""
}

func (m *Project) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Project) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Project) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func (m *Project) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Project) GetGraduationDex() string {
	if m != nil {
		return m.GraduationDex
	}
	return ""
}

func (m *Project) GetGraduated() bool {
	if m != nil {
		return m.Graduated
	}
	return false
}

func (m *Project) GetPoolSeeded() bool {
	if m != nil {
		return m.PoolSeeded
	}
	return false
}

func (m *Project) GetPoolAddress() string {
	if m != nil {
		return m.PoolAddress
	}
	return ""
}

func (m *Project) GetGraduateProgress() float64 {
	if m != nil {
		return m.GraduateProgress
	}
	return 0
}

func (m *Project) GetQuoteDenom() string {
	if m != nil {
		return m.QuoteDenom
	}
	return ""
}

func (m *Project) GetUpdatedHeight() uint64 {
	if m != nil {
		return m.UpdatedHeight
	}
	return 0
}

func (m *Project) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Project) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Metrics structure
type Metrics struct {
	MindShare      int64    `protobuf:"varint,1,opt,name=mind_share,json=mindShare,proto3" json:"mind_share,omitempty" bson:"mind_share"`
	Inferences     int64    `protobuf:"varint,2,opt,name=inferences,proto3" json:"inferences,omitempty" bson:"inferences"`
	Holders        int64    `protobuf:"varint,3,opt,name=holders,proto3" json:"holders,omitempty" bson:"holders"`
	Impressions    int64    `protobuf:"varint,4,opt,name=impressions,proto3" json:"impressions,omitempty" bson:"impressions"`
	Engagement     int64    `protobuf:"varint,5,opt,name=engagement,proto3" json:"engagement,omitempty" bson:"engagement"`
	Followers      int64    `protobuf:"varint,6,opt,name=followers,proto3" json:"followers,omitempty" bson:"followers"`
	SmartFollowers int64    `protobuf:"varint,7,opt,name=smart_followers,json=smartFollowers,proto3" json:"smart_followers,omitempty" bson:"smart_followers"`
	TopTweets      []string `protobuf:"bytes,8,rep,name=top_tweets,json=topTweets,proto3" json:"top_tweets,omitempty" bson:"top_tweets"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{3}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetMindShare() int64 {
	if m != nil {
		return m.MindShare
	}
	return 0
}

func (m *Metrics) GetInferences() int64 {
	if m != nil {
		return m.Inferences
	}
	return 0
}

func (m *Metrics) GetHolders() int64 {
	if m != nil {
		return m.Holders
	}
	return 0
}

func (m *Metrics) GetImpressions() int64 {
	if m != nil {
		return m.Impressions
	}
	return 0
}

func (m *Metrics) GetEngagement() int64 {
	if m != nil {
		return m.Engagement
	}
	return 0
}

func (m *Metrics) GetFollowers() int64 {
	if m != nil {
		return m.Followers
	}
	return 0
}

func (m *Metrics) GetSmartFollowers() int64 {
	if m != nil {
		return m.SmartFollowers
	}
	return 0
}

func (m *Metrics) GetTopTweets() []string {
	if m != nil {
		return m.TopTweets
	}
	return nil
}

// User structure
type User struct {
	Address       string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty" bson:"address"`
	CampDenom     string                `protobuf:"bytes,2,opt,name=camp_denom,json=campDenom,proto3" json:"camp_denom,omitempty" bson:"camp_denom"`
	CampAmount    cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=camp_amount,json=campAmount,proto3,customtype=cosmossdk.io/math.Int" json:"camp_amount" bson:"camp_amount"`
	UpdatedHeight uint64                `protobuf:"varint,4,opt,name=updated_height,json=updatedHeight,proto3" json:"updated_height,omitempty" bson:"updated_height"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{4}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *User) GetCampDenom() string {
	if m != nil {
		return m.CampDenom
	}
	return ""
}

func (m *User) GetUpdatedHeight() uint64 {
	if m != nil {
		return m.UpdatedHeight
	}
	return 0
}

// Agent structure
type Agent struct {
	CampDenom string `protobuf:"bytes,1,opt,name=camp_denom,json=campDenom,proto3" json:"camp_denom,omitempty" bson:"camp_denom"`
	Wallet    string `protobuf:"bytes,2,opt,name=wallet,proto3" json:"wallet,omitempty" bson:"wallet"`
}

func (m *Agent) Reset()         { *m = Agent{} }
func (m *Agent) String() string { return proto.CompactTextString(m) }
func (*Agent) ProtoMessage()    {}
func (*Agent) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{5}
}
func (m *Agent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Agent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Agent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Agent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Agent.Merge(m, src)
}
func (m *Agent) XXX_Size() int {
	return m.Size()
}
func (m *Agent) XXX_DiscardUnknown() {
	xxx_messageInfo_Agent.DiscardUnknown(m)
}

var xxx_messageInfo_Agent proto.InternalMessageInfo

func (m *Agent) GetCampDenom() string {
	if m != nil {
		return m.CampDenom
	}
	return ""
}

func (m *Agent) GetWallet() string {
	if m != nil {
		return m.Wallet
	}
	return ""
}

// Trade structure
type Trade struct {
	Address         string                `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty" bson:"address"`
	ContractAddress string                `protobuf:"bytes,2,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty" bson:"contract_address"`
	CampDenom       string                `protobuf:"bytes,3,opt,name=camp_denom,json=campDenom,proto3" json:"camp_denom,omitempty" bson:"camp_denom"`
	Action          string                `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"`
	InputCoin       *types.Coin           `protobuf:"bytes,5,opt,name=input_coin,json=inputCoin,proto3" json:"input_coin,omitempty" bson:"input_coin"`
	OutputCoin      *types.Coin           `protobuf:"bytes,6,opt,name=output_coin,json=outputCoin,proto3" json:"output_coin,omitempty" bson:"output_coin"`
	Price           cosmossdk_io_math.Int `protobuf:"bytes,7,opt,name=price,proto3,customtype=cosmossdk.io/math.Int" json:"price" bson:"price"`
	Height          uint64                `protobuf:"varint,8,opt,name=height,proto3" json:"height,omitempty" bson:"height"`
	Timestamp       int64                 `protobuf:"varint,9,opt,name=timestamp,proto3" json:"timestamp,omitempty" bson:"timestamp"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_79f6b48d89609bc8, []int{6}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Trade) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *Trade) GetCampDenom() string {
	if m != nil {
		return m.CampDenom
	}
	return ""
}

func (m *Trade) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Trade) GetInputCoin() *types.Coin {
	if m != nil {
		return m.InputCoin
	}
	return nil
}

func (m *Trade) GetOutputCoin() *types.Coin {
	if m != nil {
		return m.OutputCoin
	}
	return nil
}

func (m *Trade) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Trade) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func init() {
	proto.RegisterEnum("flux.indexer.campclash.Ops", Ops_name, Ops_value)
	proto.RegisterType((*CampEvent)(nil), "flux.indexer.campclash.CampEvent")
	proto.RegisterType((*SwapEvent)(nil), "flux.indexer.campclash.SwapEvent")
	proto.RegisterType((*Project)(nil), "flux.indexer.campclash.Project")
	proto.RegisterType((*Metrics)(nil), "flux.indexer.campclash.Metrics")
	proto.RegisterType((*User)(nil), "flux.indexer.campclash.User")
	proto.RegisterType((*Agent)(nil), "flux.indexer.campclash.Agent")
	proto.RegisterType((*Trade)(nil), "flux.indexer.campclash.Trade")
}

func init() { proto.RegisterFile("flux/indexer/campclash/camp.proto", fileDescriptor_79f6b48d89609bc8) }

var fileDescriptor_79f6b48d89609bc8 = []byte{
	// 1342 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x73, 0xdb, 0x44,
	0x14, 0x8f, 0xe2, 0xc4, 0x8e, 0xd6, 0xf9, 0x70, 0x36, 0x6d, 0xaa, 0x36, 0x8c, 0x15, 0x96, 0x4b,
	0x0a, 0xc5, 0x9e, 0xa6, 0x61, 0x0a, 0x19, 0x0e, 0xd4, 0x29, 0x81, 0xce, 0xd0, 0xa6, 0xdd, 0x86,
	0x61, 0x86, 0x8b, 0x66, 0x2d, 0x6d, 0x6d, 0x51, 0x4b, 0x2b, 0xa4, 0x75, 0xe3, 0x5e, 0xf9, 0x0b,
	0x38, 0xf0, 0xcf, 0x70, 0xe7, 0xd0, 0x13, 0xd3, 0x23, 0xc3, 0x41, 0xc3, 0xb4, 0x37, 0x8e, 0xba,
	0x33, 0xc3, 0xec, 0x87, 0xec, 0x75, 0xd2, 0xe2, 0x96, 0x76, 0x7a, 0xd3, 0xbe, 0xf7, 0x7b, 0xbf,
	0xfd, 0xfa, 0xbd, 0xb7, 0x4f, 0xe0, 0xfd, 0x07, 0x83, 0xe1, 0xa8, 0x1d, 0xc6, 0x01, 0x1d, 0xd1,
	0xb4, 0xed, 0x93, 0x28, 0xf1, 0x07, 0x24, 0xeb, 0xcb, 0xaf, 0x56, 0x92, 0x32, 0xce, 0xe0, 0xa6,
	0x80, 0xb4, 0x34, 0xa4, 0x35, 0x86, 0x5c, 0x3a, 0xd7, 0x63, 0x3d, 0x26, 0x21, 0x6d, 0xf1, 0xa5,
	0xd0, 0x97, 0x9a, 0x3e, 0xcb, 0x22, 0x96, 0xb5, 0xbb, 0x24, 0xa3, 0xed, 0x47, 0x57, 0xbb, 0x94,
	0x93, 0xab, 0x6d, 0x9f, 0x85, 0xb1, 0xf2, 0xa3, 0x7f, 0x2c, 0x60, 0x1f, 0x90, 0x28, 0xf9, 0xf2,
	0x11, 0x8d, 0x39, 0xa4, 0xa0, 0xe1, 0xb3, 0x98, 0xa7, 0xc4, 0xe7, 0x1e, 0x09, 0x82, 0x94, 0x66,
	0x99, 0x63, 0x6d, 0x5b, 0x3b, 0x76, 0x67, 0xff, 0xef, 0xdc, 0xdd, 0xf2, 0x4e, 0x3b, 0xaf, 0xb0,
	0x28, 0xe4, 0x34, 0x4a, 0xf8, 0xe3, 0x22, 0x77, 0x2f, 0x74, 0x33, 0x16, 0xef, 0xa3, 0xd3, 0x18,
	0x84, 0xd7, 0x4a, 0xd3, 0x0d, 0x65, 0x81, 0xfb, 0x60, 0x9e, 0x25, 0xce, 0xfc, 0xb6, 0xb5, 0xb3,
	0xba, 0xbb, 0xd5, 0x7a, 0xf1, 0x7e, 0x5a, 0x47, 0x49, 0xd6, 0x59, 0x29, 0x72, 0xd7, 0x56, 0xb4,
	0x2c, 0x41, 0x78, 0x9e, 0x25, 0xf0, 0x36, 0xa8, 0x25, 0x29, 0xfb, 0x81, 0xfa, 0xdc, 0xa9, 0x6c,
	0x5b, 0x3b, 0xf5, 0x5d, 0xf7, 0x65, 0x04, 0x77, 0x15, 0xac, 0x03, 0x8b, 0xdc, 0x5d, 0x55, 0x24,
	0x3a, 0x12, 0xe1, 0x92, 0x03, 0xfd, 0xba, 0x08, 0xec, 0xfb, 0x27, 0xe4, 0xdd, 0xee, 0x7f, 0x0f,
	0x00, 0xb1, 0x4c, 0x2f, 0xa0, 0x31, 0x8b, 0xe4, 0x39, 0xd8, 0x9d, 0xf3, 0x45, 0xee, 0xae, 0x6b,
	0x86, 0xb1, 0x0f, 0x61, 0x5b, 0x0c, 0x6e, 0x8a, 0x6f, 0x78, 0x19, 0x54, 0x89, 0xcf, 0x43, 0x16,
	0xcb, 0x8d, 0xdb, 0x9d, 0xf5, 0x22, 0x77, 0x57, 0x54, 0x84, 0xb2, 0x23, 0xac, 0x01, 0xf0, 0x08,
	0x80, 0x30, 0x4e, 0x86, 0xdc, 0x13, 0x37, 0xed, 0x2c, 0xc8, 0x73, 0xba, 0xd8, 0x52, 0x52, 0x68,
	0x09, 0x29, 0xb4, 0xb4, 0x14, 0x5a, 0x07, 0x2c, 0x8c, 0xcd, 0xb9, 0x27, 0x61, 0x08, 0xdb, 0x72,
	0x20, 0x10, 0x10, 0x83, 0x3a, 0x1b, 0xf2, 0x31, 0xe3, 0xe2, 0x2c, 0xc6, 0xcd, 0x22, 0x77, 0xa1,
	0xbe, 0xb8, 0x49, 0x1c, 0xc2, 0x40, 0x8d, 0x24, 0xe7, 0x01, 0x58, 0x4c, 0xd2, 0xd0, 0xa7, 0x4e,
	0x55, 0x6e, 0xe7, 0xe3, 0x27, 0xb9, 0x3b, 0xf7, 0x67, 0xee, 0x9e, 0x57, 0xa4, 0x59, 0xf0, 0xb0,
	0x15, 0xb2, 0x76, 0x44, 0x78, 0xbf, 0x75, 0x2b, 0xe6, 0x45, 0xee, 0x2e, 0x97, 0x77, 0x18, 0xfa,
	0x14, 0x61, 0x15, 0x0b, 0xfb, 0x00, 0xfa, 0xc3, 0xf4, 0x11, 0xf5, 0x7e, 0x1c, 0x32, 0x4e, 0x3d,
	0x12, 0xb1, 0x61, 0xcc, 0x9d, 0x9a, 0xba, 0xb3, 0x59, 0x8c, 0x17, 0xf5, 0x79, 0x9f, 0x21, 0x40,
	0xb8, 0x21, 0x8d, 0xf7, 0x84, 0xed, 0x86, 0x34, 0x41, 0x0a, 0xd6, 0x15, 0x50, 0x5e, 0x8f, 0x9e,
	0x68, 0x49, 0x4e, 0xf4, 0xd9, 0xac, 0x89, 0x1c, 0x73, 0x22, 0x23, 0x5e, 0x68, 0x43, 0xd8, 0x44,
	0x06, 0xea, 0x69, 0x2e, 0x83, 0x2a, 0x4f, 0x49, 0x40, 0x53, 0xc7, 0x3e, 0x7d, 0xcb, 0xca, 0x8e,
	0xb0, 0x06, 0xa0, 0xdf, 0x6d, 0x50, 0xd3, 0x22, 0x87, 0x87, 0x2f, 0x55, 0xee, 0xd6, 0x3b, 0x90,
	0xe6, 0x07, 0x60, 0x21, 0x26, 0x11, 0xd5, 0xc2, 0x5c, 0x2b, 0x72, 0xb7, 0xae, 0xf0, 0xc2, 0x8a,
	0xb0, 0x74, 0x8a, 0x9d, 0x65, 0x8f, 0xa3, 0x2e, 0x1b, 0x48, 0x41, 0x4e, 0xed, 0x4c, 0xd9, 0x11,
	0xd6, 0x00, 0xc1, 0x37, 0x60, 0x3d, 0x26, 0x75, 0x36, 0xc5, 0x27, 0xac, 0x08, 0x4b, 0x27, 0xbc,
	0x02, 0x6a, 0x7e, 0x4a, 0x09, 0x67, 0xa9, 0x56, 0x90, 0x91, 0xe8, 0xda, 0x81, 0x70, 0x09, 0x81,
	0x0c, 0x9c, 0xeb, 0xa5, 0x24, 0x18, 0x12, 0x91, 0x20, 0x1e, 0xef, 0xa7, 0x34, 0xeb, 0xb3, 0x41,
	0xa0, 0xa5, 0xf2, 0xf9, 0xac, 0x1b, 0xdc, 0x52, 0xbc, 0x2f, 0xa2, 0x40, 0x78, 0x63, 0x62, 0x3e,
	0x2e, 0xad, 0xf0, 0x0b, 0xb0, 0x6a, 0xa0, 0x03, 0x3a, 0xd2, 0x62, 0xb9, 0x58, 0xe4, 0xee, 0xf9,
	0x33, 0x6c, 0x01, 0x1d, 0x21, 0xbc, 0x32, 0x31, 0xdc, 0xa4, 0x23, 0xb8, 0x0b, 0x6c, 0x6d, 0xa0,
	0x81, 0x54, 0xc3, 0x52, 0xe7, 0x5c, 0x91, 0xbb, 0x8d, 0xa9, 0x60, 0x1a, 0x20, 0x3c, 0x81, 0xc1,
	0xeb, 0xa0, 0x9e, 0x30, 0x36, 0xf0, 0x32, 0x4a, 0x03, 0x1a, 0x38, 0x40, 0x46, 0x19, 0xd9, 0x68,
	0x38, 0x11, 0x06, 0x62, 0x74, 0x5f, 0x0e, 0xe0, 0x3e, 0x58, 0x96, 0xbe, 0x52, 0x3c, 0x75, 0xb9,
	0xd8, 0x0b, 0x45, 0xee, 0x6e, 0x18, 0x91, 0x63, 0xe1, 0xc8, 0x59, 0x4a, 0xd1, 0xdc, 0x02, 0xeb,
	0xe5, 0x0a, 0xbc, 0x24, 0x65, 0x3d, 0x49, 0xb0, 0xbc, 0x6d, 0xed, 0x58, 0x9d, 0xf7, 0x26, 0xea,
	0x3f, 0x03, 0x41, 0xb8, 0x51, 0xda, 0xee, 0x6a, 0x13, 0x3c, 0x06, 0x75, 0x33, 0xbf, 0x56, 0xe4,
	0x2a, 0xae, 0xcd, 0xba, 0x1d, 0x68, 0xa8, 0xb3, 0xcc, 0x2c, 0xa9, 0x63, 0x9d, 0x54, 0xd7, 0x41,
	0x5d, 0xa5, 0xb7, 0x92, 0xf5, 0xaa, 0x64, 0x35, 0x4e, 0xc5, 0x70, 0x22, 0x0c, 0xe4, 0x48, 0x09,
	0xfb, 0x3b, 0xb0, 0x3c, 0x55, 0x58, 0xd6, 0x64, 0xe4, 0xde, 0xac, 0xf5, 0x6c, 0x98, 0xb4, 0xe5,
	0x82, 0xd4, 0x12, 0xf4, 0x8a, 0xee, 0x01, 0x10, 0x91, 0xf4, 0x21, 0xe5, 0x9e, 0x4f, 0x12, 0xa7,
	0x21, 0x69, 0x77, 0x67, 0xd1, 0xea, 0x24, 0x9c, 0x04, 0x22, 0x6c, 0xab, 0xc1, 0x01, 0x49, 0x84,
	0xe0, 0x86, 0x49, 0x20, 0x54, 0xe0, 0xf5, 0x69, 0xd8, 0xeb, 0x73, 0x67, 0x7d, 0xdb, 0xda, 0x59,
	0x30, 0x05, 0x37, 0xed, 0x47, 0x78, 0x45, 0x1b, 0xbe, 0x96, 0x63, 0xd8, 0x06, 0x4b, 0x11, 0xe5,
	0x24, 0x20, 0x9c, 0x38, 0x50, 0x2e, 0x69, 0xa3, 0xc8, 0xdd, 0x35, 0x3d, 0xab, 0xf6, 0x20, 0x3c,
	0x06, 0x89, 0xc7, 0x38, 0xa2, 0x3c, 0x0d, 0xfd, 0xcc, 0xd9, 0xf8, 0xef, 0xc7, 0xf8, 0xb6, 0x82,
	0x99, 0x39, 0xaa, 0x23, 0x11, 0x2e, 0x39, 0xd0, 0x6f, 0x15, 0x50, 0xd3, 0x40, 0x51, 0x88, 0xa2,
	0x30, 0x0e, 0xbc, 0xac, 0x4f, 0x52, 0x2a, 0x4b, 0x59, 0xc5, 0x2c, 0x44, 0x13, 0x9f, 0x38, 0x83,
	0x30, 0x0e, 0xee, 0x8b, 0x6f, 0xf8, 0x89, 0x78, 0xf8, 0x1e, 0xd0, 0x94, 0xc6, 0x3e, 0xcd, 0x64,
	0xf9, 0xaa, 0x4c, 0xbf, 0x6e, 0xa5, 0x0f, 0x61, 0x03, 0x28, 0x4a, 0x89, 0xc8, 0x59, 0x9a, 0x66,
	0xb2, 0x84, 0x55, 0xcc, 0x65, 0x6a, 0x07, 0xc2, 0x25, 0x04, 0x7e, 0x0a, 0xea, 0x61, 0x94, 0x08,
	0xb9, 0x86, 0x2c, 0xce, 0x64, 0x35, 0xab, 0x98, 0x6a, 0x32, 0x9c, 0x08, 0x9b, 0x50, 0xb1, 0x3c,
	0x1a, 0xf7, 0x48, 0x8f, 0x46, 0x34, 0xe6, 0xb2, 0xba, 0x4d, 0x2d, 0x6f, 0xe2, 0x43, 0xd8, 0x00,
	0x8a, 0x42, 0xf0, 0x80, 0x0d, 0x06, 0xec, 0x44, 0x2c, 0xb0, 0x2a, 0xa3, 0x8c, 0x42, 0x30, 0x76,
	0x21, 0x3c, 0x81, 0xc1, 0x03, 0xb0, 0x96, 0x45, 0x24, 0xe5, 0xde, 0x24, 0xb2, 0x26, 0x23, 0x2f,
	0x15, 0xb9, 0xbb, 0xa9, 0xcb, 0xee, 0x34, 0x00, 0xe1, 0x55, 0x69, 0x39, 0x1c, 0x93, 0xec, 0x01,
	0xc0, 0x59, 0xe2, 0xf1, 0x13, 0x4a, 0x79, 0xe6, 0x2c, 0x6d, 0x57, 0xa6, 0x5f, 0x83, 0x89, 0x0f,
	0x61, 0x9b, 0xb3, 0xe4, 0x58, 0x7d, 0xff, 0x34, 0x0f, 0x16, 0xbe, 0xcd, 0x68, 0x2a, 0x8e, 0x75,
	0xfa, 0x2d, 0x32, 0x8e, 0x75, 0x5c, 0x49, 0x4a, 0xc8, 0xff, 0x7c, 0x7a, 0x4e, 0x15, 0x8c, 0xca,
	0xdb, 0x29, 0x18, 0x67, 0x73, 0x69, 0xe1, 0xf5, 0x72, 0x09, 0xf5, 0xc1, 0xe2, 0x8d, 0x9e, 0xb8,
	0xbc, 0xe9, 0x6d, 0x59, 0xaf, 0xde, 0xec, 0x9d, 0x90, 0xc1, 0x80, 0x72, 0x7d, 0x10, 0xc6, 0x63,
	0xa9, 0xec, 0x08, 0x6b, 0x00, 0xfa, 0x65, 0x01, 0x2c, 0x1e, 0x8b, 0x8e, 0xe0, 0x35, 0xcf, 0xfb,
	0x45, 0x2d, 0xc3, 0xfc, 0x1b, 0xb7, 0x0c, 0x95, 0x57, 0xdc, 0xe0, 0xe6, 0xb8, 0x9b, 0x95, 0xdd,
	0xc0, 0x4b, 0x5a, 0xd7, 0xc5, 0xb7, 0xde, 0xba, 0x56, 0xdf, 0x6a, 0xeb, 0x5a, 0x7b, 0x83, 0xd6,
	0xf5, 0x32, 0xa8, 0x6a, 0x6d, 0x2d, 0x49, 0x6d, 0x19, 0x57, 0x5c, 0x6a, 0x4a, 0x03, 0x44, 0x01,
	0xe0, 0x61, 0x44, 0x33, 0x4e, 0xa2, 0x44, 0x76, 0x02, 0x53, 0x05, 0x60, 0xec, 0x12, 0x59, 0x58,
	0x7e, 0x7f, 0xf8, 0x11, 0xa8, 0x1c, 0x25, 0x19, 0x6c, 0x80, 0xe5, 0xa3, 0xe4, 0x40, 0x34, 0x41,
	0xb2, 0xcb, 0x6c, 0xcc, 0x41, 0x08, 0x56, 0x8f, 0x92, 0xaf, 0xf4, 0xc3, 0x2b, 0x6d, 0x56, 0xe7,
	0xce, 0x93, 0x67, 0x4d, 0xeb, 0xe9, 0xb3, 0xa6, 0xf5, 0xd7, 0xb3, 0xa6, 0xf5, 0xf3, 0xf3, 0xe6,
	0xdc, 0xd3, 0xe7, 0xcd, 0xb9, 0x3f, 0x9e, 0x37, 0xe7, 0xbe, 0xdf, 0xeb, 0x85, 0xbc, 0x3f, 0xec,
	0xb6, 0x7c, 0x16, 0xb5, 0x0f, 0x07, 0xc3, 0xd1, 0x9d, 0xc3, 0xe3, 0x6f, 0x48, 0x37, 0x6b, 0x8b,
	0x3a, 0x1f, 0xb4, 0xfd, 0x3e, 0x09, 0xe3, 0xb3, 0xff, 0xab, 0xdd, 0xaa, 0xfc, 0xbb, 0xbc, 0xf6,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x03, 0x6a, 0x7f, 0xd0, 0x0e, 0x00, 0x00,
}

func (m *CampEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CampEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CampEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SwapEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwapEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Trader) > 0 {
		i -= len(m.Trader)
		copy(dAtA[i:], m.Trader)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Trader)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size := m.CurveCampAmount.Size()
		i -= size
		if _, err := m.CurveCampAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.CurveQuoteAmount.Size()
		i -= size
		if _, err := m.CurveQuoteAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.OutputCoin != nil {
		{
			size, err := m.OutputCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InputCoin != nil {
		{
			size, err := m.InputCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CampDenom) > 0 {
		i -= len(m.CampDenom)
		copy(dAtA[i:], m.CampDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.CampDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metrics != nil {
		{
			size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.UpdatedHeight != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.UpdatedHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	{
		size := m.MarketCap.Size()
		i -= size
		if _, err := m.MarketCap.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size := m.QuoteAmount.Size()
		i -= size
		if _, err := m.QuoteAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if len(m.QuoteDenom) > 0 {
		i -= len(m.QuoteDenom)
		copy(dAtA[i:], m.QuoteDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.QuoteDenom)))
		i--
		dAtA[i] = 0x72
	}
	{
		size := m.CampAmount.Size()
		i -= size
		if _, err := m.CampAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if m.GraduateProgress != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GraduateProgress))))
		i--
		dAtA[i] = 0x61
	}
	if len(m.PoolAddress) > 0 {
		i -= len(m.PoolAddress)
		copy(dAtA[i:], m.PoolAddress)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.PoolAddress)))
		i--
		dAtA[i] = 0x5a
	}
	if m.PoolSeeded {
		i--
		if m.PoolSeeded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Graduated {
		i--
		if m.Graduated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.GraduationDex) > 0 {
		i -= len(m.GraduationDex)
		copy(dAtA[i:], m.GraduationDex)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.GraduationDex)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.GraduationThreshold.Size()
		i -= size
		if _, err := m.GraduationThreshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Logo) > 0 {
		i -= len(m.Logo)
		copy(dAtA[i:], m.Logo)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Logo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CampDenom) > 0 {
		i -= len(m.CampDenom)
		copy(dAtA[i:], m.CampDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.CampDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopTweets) > 0 {
		for iNdEx := len(m.TopTweets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TopTweets[iNdEx])
			copy(dAtA[i:], m.TopTweets[iNdEx])
			i = encodeVarintCamp(dAtA, i, uint64(len(m.TopTweets[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.SmartFollowers != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.SmartFollowers))
		i--
		dAtA[i] = 0x38
	}
	if m.Followers != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Followers))
		i--
		dAtA[i] = 0x30
	}
	if m.Engagement != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Engagement))
		i--
		dAtA[i] = 0x28
	}
	if m.Impressions != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Impressions))
		i--
		dAtA[i] = 0x20
	}
	if m.Holders != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Holders))
		i--
		dAtA[i] = 0x18
	}
	if m.Inferences != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Inferences))
		i--
		dAtA[i] = 0x10
	}
	if m.MindShare != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.MindShare))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedHeight != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.UpdatedHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.CampAmount.Size()
		i -= size
		if _, err := m.CampAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.CampDenom) > 0 {
		i -= len(m.CampDenom)
		copy(dAtA[i:], m.CampDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.CampDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Agent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Agent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Agent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Wallet) > 0 {
		i -= len(m.Wallet)
		copy(dAtA[i:], m.Wallet)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Wallet)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CampDenom) > 0 {
		i -= len(m.CampDenom)
		copy(dAtA[i:], m.CampDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.CampDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x48
	}
	if m.Height != 0 {
		i = encodeVarintCamp(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.Price.Size()
		i -= size
		if _, err := m.Price.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCamp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.OutputCoin != nil {
		{
			size, err := m.OutputCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.InputCoin != nil {
		{
			size, err := m.InputCoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCamp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CampDenom) > 0 {
		i -= len(m.CampDenom)
		copy(dAtA[i:], m.CampDenom)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.CampDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintCamp(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCamp(dAtA []byte, offset int, v uint64) int {
	offset -= sovCamp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CampEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovCamp(uint64(m.Op))
	}
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovCamp(uint64(l))
	}
	return n
}

func (m *SwapEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.CampDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.InputCoin != nil {
		l = m.InputCoin.Size()
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.OutputCoin != nil {
		l = m.OutputCoin.Size()
		n += 1 + l + sovCamp(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = m.CurveQuoteAmount.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = m.CurveCampAmount.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = len(m.Trader)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	return n
}

func (m *Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.CampDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = m.GraduationThreshold.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = len(m.GraduationDex)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.Graduated {
		n += 2
	}
	if m.PoolSeeded {
		n += 2
	}
	l = len(m.PoolAddress)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.GraduateProgress != 0 {
		n += 9
	}
	l = m.CampAmount.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = len(m.QuoteDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = m.QuoteAmount.Size()
	n += 1 + l + sovCamp(uint64(l))
	l = m.MarketCap.Size()
	n += 2 + l + sovCamp(uint64(l))
	if m.UpdatedHeight != 0 {
		n += 2 + sovCamp(uint64(m.UpdatedHeight))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 2 + l + sovCamp(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 2 + l + sovCamp(uint64(l))
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MindShare != 0 {
		n += 1 + sovCamp(uint64(m.MindShare))
	}
	if m.Inferences != 0 {
		n += 1 + sovCamp(uint64(m.Inferences))
	}
	if m.Holders != 0 {
		n += 1 + sovCamp(uint64(m.Holders))
	}
	if m.Impressions != 0 {
		n += 1 + sovCamp(uint64(m.Impressions))
	}
	if m.Engagement != 0 {
		n += 1 + sovCamp(uint64(m.Engagement))
	}
	if m.Followers != 0 {
		n += 1 + sovCamp(uint64(m.Followers))
	}
	if m.SmartFollowers != 0 {
		n += 1 + sovCamp(uint64(m.SmartFollowers))
	}
	if len(m.TopTweets) > 0 {
		for _, s := range m.TopTweets {
			l = len(s)
			n += 1 + l + sovCamp(uint64(l))
		}
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.CampDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = m.CampAmount.Size()
	n += 1 + l + sovCamp(uint64(l))
	if m.UpdatedHeight != 0 {
		n += 1 + sovCamp(uint64(m.UpdatedHeight))
	}
	return n
}

func (m *Agent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CampDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Wallet)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.CampDenom)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.InputCoin != nil {
		l = m.InputCoin.Size()
		n += 1 + l + sovCamp(uint64(l))
	}
	if m.OutputCoin != nil {
		l = m.OutputCoin.Size()
		n += 1 + l + sovCamp(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovCamp(uint64(l))
	if m.Height != 0 {
		n += 1 + sovCamp(uint64(m.Height))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCamp(uint64(m.Timestamp))
	}
	return n
}

func sovCamp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCamp(x uint64) (n int) {
	return sovCamp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CampEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CampEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CampEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Ops(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputCoin == nil {
				m.InputCoin = &types.Coin{}
			}
			if err := m.InputCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCoin == nil {
				m.OutputCoin = &types.Coin{}
			}
			if err := m.OutputCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurveQuoteAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurveQuoteAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurveCampAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurveCampAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraduationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GraduationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraduationDex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraduationDex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Graduated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Graduated = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PoolSeeded = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraduateProgress", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GraduateProgress = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CampAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.QuoteAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketCap", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarketCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedHeight", wireType)
			}
			m.UpdatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &Metrics{}
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MindShare", wireType)
			}
			m.MindShare = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MindShare |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inferences", wireType)
			}
			m.Inferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inferences |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holders", wireType)
			}
			m.Holders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Holders |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impressions", wireType)
			}
			m.Impressions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Impressions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Engagement", wireType)
			}
			m.Engagement = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Engagement |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Followers", wireType)
			}
			m.Followers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Followers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartFollowers", wireType)
			}
			m.SmartFollowers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmartFollowers |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopTweets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopTweets = append(m.TopTweets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CampAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedHeight", wireType)
			}
			m.UpdatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Agent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Agent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Agent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wallet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wallet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CampDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputCoin == nil {
				m.InputCoin = &types.Coin{}
			}
			if err := m.InputCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCoin == nil {
				m.OutputCoin = &types.Coin{}
			}
			if err := m.OutputCoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCamp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCamp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCamp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCamp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCamp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCamp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCamp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCamp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCamp = fmt.Errorf("proto: unexpected end of group")
)
